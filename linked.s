




; boot.s
; there is no need to load the kernel high at boot
; dme has no awkward io mappings in low memory
; so:
; - we will load it at 0x0 at map it high
; - then jump into the high mapping

; lets assume (oh o) for now that the entire kernel is 2 pages
; and that dme will come up in system mode..

; setup mapping of kernel to 0x1000
; page 2 -> 0
; page 3 -> 1
; page 6 -> 6

; this code is linked at 0x1000 so it works when paging is on
.code 0x1000

ldi r1, 0x3
ldi r2, 0x22
wpte r2, r1

ldi r2, 0x103
ldi r3, 0x23
wpte r3, r2

; identity map the first 2 pages or execution would stop
ldi r3, 32
wpte r3, r1
ldi r3, 33
ldi r1, 1
wpte r3, r2

; and the i/o memory mapped page
ld16 r2, 0x703
ldi r1, 0x3f
wpte r1, r2
ldi r3, 32
wptb r3
; turn on paging (not yet)
lcr r1
ori r1, r1, 4
wcr r1

; setup IVEC
la16 r1, _alltraps
wivec r1

; setup SP
la16 r1, 0xff00
mov sp, r1



; jump into c
la16 r2, _kmain
; setup return address in case kmain returns (it shouldn't)
addi r1, pc, 2
br.r r2
hlt











;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff

	.data 0x1000
L2_console:
	defb 48
	defb 49
	defb 50
	defb 51
	defb 52
	defb 53
	defb 54
	defb 55
	defb 56
	defb 57
	defb 97
	defb 98
	defb 99
	defb 100
	defb 101
	defb 102
	defb 0
;	.code
_printint:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 28
	sub	sp, sp, r4
	ldw	r3,8(bp)
	skip.ne	r3,r0
	br	L3_console
	ldw	r3,4(bp)
	skip.lt r3, r0
	br L6_console
	ld16	r4, 1
	stw	-22(bp),r4
	la16	r4,L7_console
	br.r r4
L6_console:
	stw	-22(bp),r0
L7_console:
	ldw	r4,-22(bp)
	stw	8(bp),r4
	skip.ne	r4,r0
	br	L3_console
	ldw	r4,4(bp)
sub	r4,r0,r4
	stw	-4(bp),r4
	la16	r4,L4_console
	br.r r4
L3_console:
	ldw	r4,4(bp)
	stw	-4(bp),r4
L4_console:
	stw	-2(bp),r0
L8_console:
	ldw	r4,-2(bp)
	addi	r3,r4,1
	stw	-2(bp),r3
	ldi	r3, -20
	add	r3, r3, bp
	add	r4,r4,r3
	stw	-28(bp),r4
	ldw	r3,-4(bp)
	stw	-24(bp),r3
	ldw	r2,6(bp)
	stw	-26(bp),r2

push bp
push r3
push r2
addi bp, pc, 2
br _mod
; result should be in r1
pop bp

	la16	r4,L2_console
	add	r4,r1,r4
	ldb	r4,r0(r4)
	ldw	r3,-28(bp)
	stb	r0(r3),r4
L9_console:
	ldw	r4,-4(bp)
	ldw	r3,6(bp)

push bp
push r4
push r3
addi bp, pc, 2
br _div
; result should be in r1
pop bp

	stw	-4(bp),r1
	skip.eq r1,r0
	br L8_console
	ldw	r4,8(bp)
	skip.ne	r4,r0
	br	L1_console4_console
	ldw	r4,-2(bp)
	addi	r3,r4,1
	stw	-2(bp),r3
	ldi	r3, -20
	add	r3, r3, bp
	add	r4,r4,r3
	ld16	r3, 45
	stb	r0(r4),r3
	la16	r4,L1_console4_console
	br.r r4
L1_console3_console:
	ldw	r4,-2(bp)
	ldi	r3, -20
	add	r3, r3, bp
	add	r4,r4,r3
	ldb	r4,r0(r4)
	push	r4
	la16	r2,_putc
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
L1_console4_console:
	ldw	r4,-2(bp)
	subi	r4,r4,1
	stw	-2(bp),r4
	skip.lt r4, r0
	br L1_console3_console
L1_console:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _kprintf
_kprintf:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 8
	sub	sp, sp, r4
	ldi	r4, 6
	add	r4, r4, bp
	stw	-8(bp),r4
	stw	-6(bp),r0
	la16	r4,L2_console1
	br.r r4
L1_console8:
	ldw	r4,-2(bp)
	ld16	r3, 37
	skip.ne	r4,r3
	br	L2_console2
	ldw	r4,-2(bp)
	push	r4
	la16	r2,_putc
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
	la16	r4,L1_console9
	br.r r4
L2_console2:
	ldw	r4,-6(bp)
	addi	r4,r4,1
	stw	-6(bp),r4
	ldw	r3,4(bp)
	add	r4,r4,r3
	ldb	r4,r0(r4)
	ld16	r3, 255
	and	r4,r4,r3
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	skip.eq r4,r0
	br L2_console4
	la16	r4,L2_console0
	br.r r4
L2_console4:
	ldw	r4,-2(bp)
	ld16	r3, 104
	skip.ne	r4,r3
	br	L2_console9
	skip.lte	r4,r3
	br	L4_console0
L3_console9:
	ldw	r4,-2(bp)
	ld16	r3, 37
	skip.ne	r4,r3
	br	L3_console8
	skip.gte	r4,r3
	br	L2_console6
L4_console1:
	ldw	r4,-2(bp)
	ld16	r3, 100
	skip.ne	r4,r3
	br	L2_console8
	la16	r4,L2_console6
	br.r r4
L4_console0:
	ldw	r4,-2(bp)
	ld16	r3, 112
	skip.ne	r4,r3
	br	L2_console9
	ld16	r2, 115
	skip.ne	r4,r2
	br	L3_console0
	skip.gte	r4,r3
	br	L2_console6
L4_console2:
	ldw	r4,-2(bp)
	ld16	r3, 120
	skip.ne	r4,r3
	br	L2_console9
	la16	r4,L2_console6
	br.r r4
L2_console8:
	ld16	r4, 1
	push	r4
	ld16	r4, 10
	push	r4
	ldw	r4,-8(bp)
	addi	r3,r4,2
	stw	-8(bp),r3
	ldw	r4,r0(r4)
	push	r4
	la16	r2,_printint ; jaddr
	addi	r1,pc,2
	br.r	r2
	la16	r4,L2_console7
	br.r r4
L2_console9:
	push	r0
	ld16	r4, 16
	push	r4
	ldw	r4,-8(bp)
	addi	r3,r4,2
	stw	-8(bp),r3
	ldw	r4,r0(r4)
	push	r4
	la16	r2,_printint ; jaddr
	addi	r1,pc,2
	br.r	r2
	la16	r4,L2_console7
	br.r r4
L3_console0:
	ldw	r4,-8(bp)
	addi	r3,r4,2
	stw	-8(bp),r3
	ldw	r4,r0(r4)
	stw	-4(bp),r4
	skip.eq r4,r0
	br L3_console7
	la16	r4,L3_console3
	stw	-4(bp),r4
	la16	r4,L3_console7
	br.r r4
L3_console4:
	ldw	r4,-4(bp)
	ldb	r4,r0(r4)
	push	r4
	la16	r2,_putc
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
L3_console5:
	ldw	r4,-4(bp)
	addi	r4,r4,1
	stw	-4(bp),r4
L3_console7:
	ldw	r4,-4(bp)
	ldb	r4,r0(r4)
	skip.eq r4,r0
	br L3_console4
	la16	r4,L2_console7
	br.r r4
L3_console8:
	ld16	r4, 37
	push	r4
	la16	r2,_putc
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
	la16	r4,L2_console7
	br.r r4
L2_console6:
	ld16	r4, 37
	push	r4
	la16	r2,_putc
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
	ldw	r4,-2(bp)
	push	r4
	la16	r2,_putc
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
L2_console7:
L1_console9:
	ldw	r4,-6(bp)
	addi	r4,r4,1
	stw	-6(bp),r4
L2_console1:
	ldw	r4,-6(bp)
	ldw	r3,4(bp)
	add	r4,r4,r3
	ldb	r4,r0(r4)
	ld16	r3, 255
	and	r4,r4,r3
	stw	-2(bp),r4
	skip.eq r4,r0
	br L1_console8
L2_console0:
L1_console6:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _putc
	.data
L3_console3:
	defb 40
	defb 110
	defb 117
	defb 108
	defb 108
	defb 41
	defb 0
;	.end
_putc:
	; satisfy calling convention
	; we are not using stack so we can ommit some
	push r1
	push bp
	mov bp, sp
	; setup a pointer to uart reg at 0xff90
	la16 r4, 0xff90

	; wait until tx is free
check_tx_free_uart:
	ldi r1, 5
	add r1, r1, r4
	ldw r1, r0(r1)
	ldi r2, 0x60
	and r1, r1, r2
	skip.eq r2, r1
	br check_tx_free_uart
	; tx is free, load char (SP+2) and write to UART
	addi r1, bp, 4
	ldw r3, r0(r1)
	stb r0(r4), r3
	pop	bp
	pop	pc


_inituart:
	push r1
	push bp
	la16 r1, 0xff90
	mov r5, r1
	mov r1, r0
	stw 1(bp), r1   ; port + 1 0x00 - disable all interrupts
	ldi r1, 0x80
	stw 3(bp), r1   ; port + 3 0x80 enable dlab
	ldi r1, 52
	stw 0(bp), r1		; port + 0 set divisor to 1 LSB
	ldi r1, 0
	stw 1(bp), r1		; port + 1 set divisor to 1 MSB
	ldi r1, 3
	stw 3(bp), r1		; port + 3 set LCR - validate
	pop	bp
	pop	pc; MEMSET (char *dst, int c, uint n)
; bp + 8 has n
; bp + 6 has c
; bp + 4 has dst

_memset:
	push	r1
	push	bp
	mov	bp, sp
	ldw	r1,4(bp) ; load dst
	ldw	r2,6(bp) ; load c
	ldw	r3,8(bp) ; load n
	; skip if n = aligned
	andi r4,r3,1
	skip.eq r4, r0
	br _stosb
	; skip if dst = aligned
	andi r4, r1, 1
	skip.eq r4, r0
	br _stosb
	; both n and dst are 2 byte aligned
	shl r4, r2, 8
	or r2, r2, r4
	subi r3, r3, 2
_stoswL1:
	add	r4,r1,r3
	stw	r0(r4),r2
	addskpi.z r3, r3, -2
	br _stoswL1
	stw r0(r1), r2
	br _memsetend
_stosb:
	subi r3, r3, 1
_stosbL1:
	add	r4,r1,r3
	stb	r0(r4),r2
	addskpi.z r3, r3, -1
	br _stosbL1
	stb r0(r1), r2
_memsetend:
	pop	bp
	pop	pc

_halt:
  hlt

_breek:
	push r1
	brk
	pop pc

_writepte:
	push r1
	push bp
	mov bp, sp
	ldw r1, 4(bp)
	ldw r2, 6(bp)
	wpte r1, r2
	pop bp
	pop pc

_switchptb:
	push r1
	push bp
	mov bp, sp
	ldw r1, 4(bp)
	wptb r1
	pop bp
	pop pc

_clearptb:
; clear all page entries in an address space
	push r1
	push bp
	mov bp, sp
	ldw r1, 4(bp)
	ldi r2, 32 ; one extra cause we sub 1 in loop
	add r2, r1, r2
_clearptbL1:
	subi r2, r2, 1
	wpte r2, 0
	skip.eq r2, r1
	br _clearptbL1
	pop bp
	pop pc

_memmove:
	push	r1
	push	bp
	mov	bp, sp
	ldw	r4,4(bp)    ; dst
	ldw	r3,6(bp)    ; src
	ldw	r2,8(bp)    ; n
	add	r4,r4,r2
	add	r3,r3,r2
	br _memmoveL3
_memmoveL2:
	subi	r2,r2,1
	addi	r3,r3,-1
	addi	r4,r4,-1
	ldb	r1,r0(r3)
	stb	r0(r4),r1
_memmoveL3:
	skip.eq r2,r0
	br _memmoveL2
	mov	r1,r3
	mov	sp, bp
	pop	bp
	pop	pc;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff

;	.global _initkmem
;	.code
_initkmem:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 2
	sub	sp, sp, r4
	ld16	r4, 1
	stw	-2(bp),r4
L2_kalloc:
	ldw	r4,-2(bp)
	shl	r4, r4, 1 ; [via index]
	la16	r3,_pframe
	ld16	r2, 0xffff
	stw	r4(r3),r2
L3_kalloc:
	ldw	r4,-2(bp)
	addi	r4,r4,1
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	ld16	r3, 14
	skip.gt	r4,r3
	br	L2_kalloc
	la16	r4,_pframe
	ld16	r3, 4095
	stw	r0(r4),r3
	la16	r4,_pframe+30
	ld16	r3, 0xfffe
	stw	r0(r4),r3
L1_kalloc:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _findfreepg
_findfreepg:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 6
	sub	sp, sp, r4
	stw	-6(bp),r0
L8_kalloc:
	ldw	r4,-6(bp)
	shl	r4, r4, 1 ; [via index]
	la16	r3,_pframe
	ldw	r4,r4(r3)
	skip.eq r4,r0
	br L1_kalloc2
	la16	r4,L9_kalloc
	br.r r4
L1_kalloc2:
	ld16	r4, 15
	stw	-2(bp),r4
L1_kalloc4:
	ld16	r4, 1
	ldw	r3,-2(bp)
	shl.r	r4, r4, r3
	stw	-4(bp),r4
	ldw	r4,-4(bp)
	ldw	r3,-6(bp)
	shl	r3, r3, 1 ; [via index]
	la16	r2,_pframe
	ldw	r3,r3(r2)
	and	r4,r4,r3
	skip.ne	r4,r0
	br	L1_kalloc8
	ldw	r4,-6(bp)
	shl	r4, r4, 4
	ld16	r3, 15
	ldw	r2,-2(bp)
	sub	r3,r3,r2
	add	r4,r4,r3
	mov	r1,r4
	la16	r4,L7_kalloc
	br.r r4
L1_kalloc8:
L1_kalloc5:
	ldw	r4,-2(bp)
	subi	r4,r4,1
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	skip.lt r4, r0
	br L1_kalloc4
L9_kalloc:
	ldw	r4,-6(bp)
	addi	r4,r4,1
	stw	-6(bp),r4
	ldw	r4,-6(bp)
	ld16	r3, 16
	skip.gt	r4,r3
	br	L8_kalloc
	la16	r4,L2_kalloc0
	push	r4
	la16	r2,_kprintf
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
	mov	r1,r0
L7_kalloc:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _kalloc
_kalloc:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 16
	sub	sp, sp, r4
	la16	r2,_findfreepg ; jaddr
	addi	r1,pc,2
	br.r	r2
	mov	r4,r1
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	stw	-8(bp),r4
	ld16	r3, 16
	stw	-10(bp),r3

push bp
push r4
push r3
addi bp, pc, 2
br _div
; result should be in r1
pop bp

	stw	-4(bp),r1
	ld16	r4, 1
	stw	-16(bp),r4
	ld16	r3, 15
	stw	-14(bp),r3
	ldw	r2,-8(bp)
	stw	-12(bp),r2
	ldw	r1,-10(bp)

push bp
push r2
push r1
addi bp, pc, 2
br _mod
; result should be in r1
pop bp

	ldw	r4,-14(bp)
	sub	r4,r4,r1
	ldw	r3,-16(bp)
	shl.r	r4, r3, r4
	sub	r4,r0,r4
	subi	r4,r4,1
	stw	-6(bp),r4
	ldw	r4,-4(bp)
	shl	r4, r4, 1
	la16	r3,_pframe
	add	r4,r4,r3
	ldw	r3,r0(r4)
	ldw	r2,-6(bp)
	and	r3,r3,r2
	stw	r0(r4),r3
	ldw	r4,-2(bp)
	mov	r1,r4
L2_kalloc1:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _kprintf
	.bss
;	.global _pframe
_pframe:
	defs 32
	.data
L2_kalloc0:
	defb 70
	defb 105
	defb 110
	defb 100
	defb 102
	defb 114
	defb 101
	defb 101
	defb 112
	defb 103
	defb 58
	defb 32
	defb 78
	defb 79
	defb 32
	defb 70
	defb 82
	defb 69
	defb 69
	defb 32
	defb 80
	defb 65
	defb 71
	defb 69
	defb 32
	defb 70
	defb 79
	defb 85
	defb 78
	defb 68
	defb 33
	defb 10
	defb 0
;	.end
;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff

	.data 0x1000
;	.global _kptb
_kptb:
defw 0x0
;	.global _initpag
;	.code
_initpag:
	push	r1
	push	bp
	mov	bp, sp
	la16	r2,_initkmem
	addi	r1,pc,2
	br.r	r2
L1_vm:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _setupkvm
_setupkvm:
	push	r1
	push	bp
	mov	bp, sp
	ld16	r4, 1
	push	r4
	ldw	r4,4(bp)
	addi	r4,r4,2
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ld16	r4, 257
	push	r4
	ldw	r4,4(bp)
	ld16	r3, 3
	add	r4,r4,r3
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ld16	r4, 513
	push	r4
	ldw	r4,4(bp)
	addi	r4,r4,4
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ldw	r4,6(bp)
	shl	r4, r4, 8
	ld16	r3, 3
	or	r4,r4,r3
	push	r4
	ldw	r4,4(bp)
	ld16	r3, 31
	add	r4,r4,r3
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
L2_vm:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _getkstack
_getkstack:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 4
	sub	sp, sp, r4
	la16	r2,_kalloc
	addi	r1,pc,2
	br.r	r2
	mov	r4,r1
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	shl	r4, r4, 8
	ld16	r3, 3
	or	r4,r4,r3
	stw	-4(bp),r4
	ldw	r4,-4(bp)
	push	r4
	ld16	r4, 62
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ldw	r1,-2(bp)
L3_vm:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _addpage
_addpage:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 4
	sub	sp, sp, r4
	ldw	r4,6(bp)
	stb	6(bp),r4
	la16	r2,_kalloc
	addi	r1,pc,2
	br.r	r2
	mov	r4,r1
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	shl	r4, r4, 8
	ldb	r3,6(bp)
	or	r4,r4,r3
	stw	-4(bp),r4
	ldw	r4,-4(bp)
	push	r4
	ldw	r4,4(bp)
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ldw	r1,-2(bp)
L4_vm:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _inituvm
_inituvm:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 2
	sub	sp, sp, r4
	la16	r2,_kalloc
	addi	r1,pc,2
	br.r	r2
	mov	r4,r1
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	shl	r4, r4, 8
	ori	r4,r4,1
	push	r4
	ld16	r4, 32
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ldw	r4,-2(bp)
	shl	r4, r4, 8
	ori	r4,r4,1
	push	r4
	ldw	r4,4(bp)
	push	r4
	la16	r2,_writepte
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ld16	r4, 50
	push	r4
	ldw	r4,6(bp)
	push	r4
	push	r0
	la16	r2,_memmove
	addi	r1,pc,2
	br.r	r2
	ldi	r2,6
	add	sp,sp,r2
L5_vm:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _memmove
;	.extern _kalloc
;	.extern _writepte
;	.extern _initkmem
;	.end
;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff

;	.global _pinit
;	.code
_pinit:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 4
	sub	sp, sp, r4
	stw	-4(bp),r0
	ld16	r4, 416
	push	r4
	push	r0
	la16	r4,_ptable
	push	r4
	la16	r2,_memset
	addi	r1,pc,2
	br.r	r2
	ldi	r2,6
	add	sp,sp,r2
	la16	r4,_ptable
	stw	-2(bp),r4
	la16	r4,L5_proc
	br.r r4
L2_proc:
	ldw	r4,-2(bp)
	addi	r4,r4,2
	ldw	r3,-4(bp)
	stw	r0(r4),r3
	ldw	r4,-4(bp)
	addi	r4,r4,1
	stw	-4(bp),r4
L3_proc:
	ldw	r4,-2(bp)
	ld16	r3, 26
	add	r4,r4,r3
	stw	-2(bp),r4
L5_proc:
	ldw	r4,-2(bp)
	la16	r3,_ptable+416
	skip.ulte	r3,r4
	br	L2_proc
	la16	r4,L7_proc
	push	r4
	la16	r2,_kprintf
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
	la16	r4,_nextpid
	stw	r0(r4),r0
L1_proc:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _allocproc
_allocproc:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 4
	sub	sp, sp, r4
	la16	r4,_ptable
	stw	-2(bp),r4
	la16	r4,L1_proc2
	br.r r4
L9_proc:
	ldw	r4,-2(bp)
	addi	r4,r4,8
	ldw	r4,r0(r4)
	skip.eq r4,r0
	br L1_proc4
	la16	r4,L1_proc6
	br.r r4
L1_proc4:
L1_proc0:
	ldw	r4,-2(bp)
	ld16	r3, 26
	add	r4,r4,r3
	stw	-2(bp),r4
L1_proc2:
	ldw	r4,-2(bp)
	la16	r3,_ptable+416
	skip.ulte	r3,r4
	br	L9_proc
	la16	r4,L1_proc7
	push	r4
	la16	r2,_kprintf
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
	la16	r2,_halt
	addi	r1,pc,2
	br.r	r2
L1_proc6:
	ldw	r4,-2(bp)
	addi	r4,r4,2
	ldw	r4,r0(r4)
	push	r4
	la16	r4,L1_proc8
	push	r4
	la16	r2,_kprintf
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ld16	r4, 3
	push	r4
	ld16	r4, 62
	push	r4
	la16	r2,_addpage
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ldw	r3,-2(bp)
	ld16	r2, 6
	add	r3,r3,r2
	mov	r4,r1
	stw	r0(r3),r4
	ldw	r4,-2(bp)
	addi	r4,r4,8
	ld16	r3, 1
	stw	r0(r4),r3
	ldw	r4,-2(bp)
	ld16	r3, 10
	add	r4,r4,r3
	la16	r3,_nextpid
	ldw	r3,r0(r3)
	stw	r0(r4),r3
	la16	r4,_nextpid
	ldw	r3,r0(r4)
	addi	r3,r3,1
	stw	r0(r4),r3
	ld16	r4, 0xf700
	stw	-4(bp),r4
	ldw	r4,-4(bp)
	ld16	r3, -16
	add	r4,r4,r3
	stw	-4(bp),r4
	ldw	r4,-2(bp)
	ld16	r3, 12
	add	r4,r4,r3
	ldw	r3,-4(bp)
	ld16	r2, 2048
	add	r3,r3,r2
	stw	r0(r4),r3
	ldw	r4,-4(bp)
	addi	r4,r4,-2
	stw	-4(bp),r4
	ldw	r4,-4(bp)
	la16	r3,_cntxret
	stw	r0(r4),r3
	ldw	r4,-4(bp)
	addi	r4,r4,-2
	stw	-4(bp),r4
	ldw	r4,-2(bp)
	addi	r4,r4,4
	ldw	r3,-4(bp)
	ld16	r2, 2048
	add	r3,r3,r2
	stw	r0(r4),r3
	ldw	r1,-2(bp)
L8_proc:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _userinit
_userinit:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 4
	sub	sp, sp, r4
	la16	r2,_allocproc ; jaddr
	addi	r1,pc,2
	br.r	r2
	stw	-2(bp),r1
	ldw	r4,-2(bp)
	ld16	r3, 6
	add	r3,r4,r3
	ldw	r3,r0(r3)
	push	r3
	addi	r4,r4,2
	ldw	r4,r0(r4)
	push	r4
	la16	r2,_setupkvm
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	la16	r4,_initcodestart
	push	r4
	ldw	r4,-2(bp)
	addi	r4,r4,2
	ldw	r4,r0(r4)
	push	r4
	la16	r2,_inituvm
	addi	r1,pc,2
	br.r	r2
	ldi	r2,4
	add	sp,sp,r2
	ld16	r4, 0xf6f0
	stw	-4(bp),r4
	ldw	r4,-4(bp)
	addi	r4,r4,8
	ld16	r3, 2048
	stw	r0(r4),r3
	ldw	r4,-4(bp)
	ld16	r3, 10
	add	r4,r4,r3
	ld16	r3, 2048
	stw	r0(r4),r3
	ldw	r4,-4(bp)
	ld16	r3, 12
	add	r4,r4,r3
	stw	r0(r4),r0
	ldw	r4,-4(bp)
	ld16	r3, 14
	add	r4,r4,r3
	ld16	r3, 12
	stw	r0(r4),r3
	ldw	r4,-2(bp)
	addi	r4,r4,8
	ld16	r3, 3
	stw	r0(r4),r3
	ldw	r4,-2(bp)
	addi	r3,r4,4
	ldw	r3,r0(r3)
	push	r3
	addi	r4,r4,2
	ldw	r4,r0(r4)
	push	r4
	la16	r4,_stable
	push	r4
	la16	r2,_swtch
	addi	r1,pc,2
	br.r	r2
	ldi	r2,6
	add	sp,sp,r2
L1_proc9:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _swtch
;	.extern _inituvm
;	.extern _setupkvm
;	.extern _addpage
;	.extern _halt
;	.extern _kprintf
;	.extern _memset
;	.extern _initcodestart
;	.extern _cntxret
	.bss
;	.global _nextpid
_nextpid:
	defs 2
;	.global _stable
_stable:
	defs 2
;	.global _ptable
_ptable:
	defs 416
	.data
L1_proc8:
	defb 102
	defb 111
	defb 117
	defb 110
	defb 100
	defb 32
	defb 102
	defb 114
	defb 101
	defb 101
	defb 32
	defb 115
	defb 108
	defb 111
	defb 116
	defb 32
	defb 97
	defb 116
	defb 58
	defb 32
	defb 37
	defb 100
	defb 10
	defb 0
L1_proc7:
	defb 97
	defb 108
	defb 108
	defb 111
	defb 99
	defb 112
	defb 114
	defb 111
	defb 99
	defb 58
	defb 32
	defb 110
	defb 111
	defb 32
	defb 102
	defb 114
	defb 101
	defb 101
	defb 32
	defb 115
	defb 108
	defb 111
	defb 116
	defb 32
	defb 105
	defb 110
	defb 32
	defb 112
	defb 116
	defb 97
	defb 98
	defb 108
	defb 101
	defb 33
	defb 10
	defb 0
L7_proc:
	defb 112
	defb 105
	defb 110
	defb 105
	defb 116
	defb 58
	defb 32
	defb 112
	defb 116
	defb 97
	defb 98
	defb 108
	defb 101
	defb 32
	defb 105
	defb 110
	defb 105
	defb 116
	defb 105
	defb 97
	defb 108
	defb 105
	defb 115
	defb 101
	defb 100
	defb 46
	defb 10
	defb 0
;	.end
; when we trap we need to check if it is a timer irq (0x20)
; if it is we push all user space registers, if not than we don't...'
; the trap number is in sr1


_alltraps:
	; if r1 == 0x20 then push.u everything else not
	; FIXME: this does not handle concurrent traps yet
	ldi r3, 0x20
	and r4, r1, r3
	skip.eq r4, r3
	br simpletrap_trapasm
	hlt

_cntxret:
; we are returning from a trap after a context switch
; this means we need to restore the user registers which were saved
; to the kstack as a trapframe when we trapped
; sp is pointing at the bottom of tf (r1)
	pop.u r1
	pop.u r2
	pop.u r3
	pop.u r4
	pop.u bp
	pop.u sp
	pop.u pc
	pop r1
	wcr.u r1
	reti

simpletrap_trapasm:
	push.u sp
	push r1 	;trapnr
	la16 r3, _trap
	addi r1, pc, 2
	br.r r3

; when we return from a (non context switch) trap
trapret_trapasm:
	; we prob need to pop some more stuff of the stack but lets see
	reti
;
; to make a context switch on dme:
; - INSIGHT: a context switch is just a SP switch... ip just keeps processing
; 	- save context on old stack
; 	- switch to new address space
; 	- switch sp (from saved context)
; 	- pop context of new stack
;
; void swtch(&old->context, new_proc->ptb, new_proc->context;
_swtch:
	push r1
	push bp
	mov bp, sp
	ldw r1, 4(bp) ; sched->context (to save SP)
	ldw r2, 6(bp) ; ptb
	ldw r3, 8(bp) ; context (= new SP)
	; i dont think i need to save much except sp and bp...
	; the registers all all clear after switch is called..

	stw r0(r1), sp  ; store old sp in sched->context
	wptb r2					; switch to new address space
	mov sp, r3      ; switch sp to new stack bottom

	pop bp
	pop pc


;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff

;	.global _trap
;	.code
_trap:
	push	r1
	push	bp
	mov	bp, sp
	ldw	r4,6(bp)
	push	r4
	ldw	r4,4(bp)
	push	r4
	la16	r4,L2_trap
	push	r4
	la16	r2,_kprintf
	addi	r1,pc,2
	br.r	r2
	ldi	r2,6
	add	sp,sp,r2
	ldw	r4,4(bp)
	ld16	r3, 16
	skip.eq r4,r3
	br L3_trap
	la16	r4,L5_trap
	push	r4
	la16	r2,_kprintf
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
L3_trap:
	la16	r2,_breek
	addi	r1,pc,2
	br.r	r2
L1_trap:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _breek
;	.extern _kprintf
	.data
L5_trap:
	defb 83
	defb 89
	defb 83
	defb 67
	defb 65
	defb 76
	defb 76
	defb 33
	defb 0
L2_trap:
	defb 84
	defb 114
	defb 97
	defb 112
	defb 58
	defb 32
	defb 37
	defb 100
	defb 44
	defb 32
	defb 117
	defb 83
	defb 80
	defb 58
	defb 32
	defb 37
	defb 120
	defb 10
	defb 0
;	.end
;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff

;	.global _kmain
;	.code
_kmain:
	push	r1
	push	bp
	mov	bp, sp
	la16	r4,L2_kmain
	push	r4
	la16	r2,_kprintf
	addi	r1,pc,2
	br.r	r2
	ldi	r2,2
	add	sp,sp,r2
	la16	r2,_initkmem
	addi	r1,pc,2
	br.r	r2
	la16	r2,_pinit
	addi	r1,pc,2
	br.r	r2
	la16	r2,_userinit
	addi	r1,pc,2
	br.r	r2
	la16	r2,_halt
	addi	r1,pc,2
	br.r	r2
	mov	r1,r0
L1_kmain:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _halt
;	.extern _userinit
;	.extern _pinit
;	.extern _initkmem
;	.extern _kprintf
;	.extern _stable
;	.extern _allocproc
	.data
L2_kmain:
	defb 68
	defb 77
	defb 69
	defb 32
	defb 79
	defb 83
	defb 32
	defb 118
	defb 37
	defb 100
	defb 32
	defb 115
	defb 116
	defb 97
	defb 114
	defb 116
	defb 105
	defb 110
	defb 103
	defb 46
	defb 46
	defb 46
	defb 10
	defb 0
;	.end
; http://www.tofla.iconbar.com/tofla/arm/arm02/index.htm
; !! need to add skipi instruction to make usable (uses too many regs atm)

; DIVIDE -------------------------
;
_div:
	pop r3 ; op1
	pop r2 ; op2
	mov r1, r0
	ldi r4, 1
divL1_pseudo_ops:
	skip.gt r2, r3
	br divL2_pseudo_ops
	shl r3, r3, 1
	shl r4, r4, 1
	br divL1_pseudo_ops

divL2_pseudo_ops:
	addskpi.nz r0, r4, -1
	br divL3_pseudo_ops
	shr r3, r3, 1
	shr r4, r4, 1

	skip.gte r2, r3
	br divL2_pseudo_ops
	sub r2, r2, r3
	or	r1, r1, r4
	br divL2_pseudo_ops

divL3_pseudo_ops:
	br.r bp ; return

; MODULO -------------------------
;
; (same algo as div, just returning remainer)
_mod:
	pop r3 ; op1
	pop r2 ; op2
	ldi r4, 1
modL1_pseudo_ops:
	skip.gt r2, r3
	br modL2_pseudo_ops
	shl r3, r3, 1
	shl r4, r4, 1
	br modL1_pseudo_ops

modL2_pseudo_ops:
	addskpi.nz r0, r4, -1
	br modL3_pseudo_ops
	shr r3, r3, 1
	shr r4, r4, 1

	skip.gte r2, r3
	br modL2_pseudo_ops
	sub r2, r2, r3
	br modL2_pseudo_ops

modL3_pseudo_ops:
	mov r1, r2
	br.r bp ; return

; MULTIPLY  -------------------------
;
; (unsigned)
_mult:
	pop r2 ; op1
	pop r3 ; op2
	mov r1, r0 ; result reg
; if a > b
	skip.gt r2, r3
	br multL2_pseudo_ops
; switch them
	mov r4, r2
	mov r2, r3
	mov r3, r4

multL2_pseudo_ops:
; while r1 > 1 loop
	ldi r4, 1
	skip.gt r2, r4
	br multL3_pseudo_ops
; check if r1 is even/odd
	andi r4, r2, 1
	addskpi.nz r4, r4, -1
	add r1, r1, r3
	shr r2, r2, 1
	shl r3, r3, 1
	br multL2_pseudo_ops
multL3_pseudo_ops:
	andi r4, r1, 1
	addskpi.nz r4, r4, -1
	add r1, r1, r3
	br.r bp;  Initial process execs /init.
;
; include "syscall.h"
; include "traps.h"
;
;
;  exec(init, argv)

_initcodestart:
  la16 r1, L2_initcode
  push r1
	la16 r1, L1_initcode
  push r1
	push r0    ; where caller pc would be
  ldi r1, 7 ; syscall 7 = exec
	push r1
  syscall
	hlt

;# for(;;) exit();
;exit:
;  movl $SYS_exit, %eax
;  int $T_SYSCALL
;  jmp exit
;
;# char init[] = "/init\0";
L1_initcode:
 defstr "/init\0"
;
;# char *argv[] = { init, 0 };
;.p2align 2
;
L2_initcode:
  defw L1_initcode
	defw 0

