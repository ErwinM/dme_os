




; boot.s
; there is no need to load the kernel high at boot
; dme has no awkward io mappings in low memory
; so:
; - we will load it at 0x0 at map it high
; - then jump into the high mapping

; lets assume (oh o) for now that the entire kernel is 2 pages
; and that dme will come up in system mode..

; setup mapping of kernel to 0x1000
; page 2 -> 0
; page 3 -> 1
; page 6 -> 6

; this code is linked at 0x1000 so it works when paging is on
.code 0x1000

ldi r1, 0x3
ldi r2, 0x2
wpte r2, r1

ldi r2, 0x103
ldi r3, 3
wpte r3, r2

; identity map the first 2 pages or execution would stop
wpte r0, r1
ldi r1, 1
wpte r1, r2

;identity map the 7th page for a stack (FIXME: ON CHIP MEM)
ldi r1, 7
la16 r2, 0x703
wpte r1, r2

; and the i/o memory mapped page
ld16 r2, 0x1f03
ldi r1, 31
wpte r1, r2
wptb r0
; turn on paging (not yet)
lcr r1
ori r1, r1, 4
scr r1

; setup IVEC
la16 r1, _trap
wivec r1

; setup SP
la16 r1, 0x4000
mov sp, r1



; jump into c
la16 r2, _kmain
; setup return address in case kmain returns (it shouldn't)
addi r1, pc, 2
br.r r2
hlt

_trap:
	defw 0xbabe











;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff;	.global _kprintfold
;	.code
_kprintfold:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 2
	sub	sp, sp, r4
	stw	-2(bp),r0
	la16	r4,L3_console
	br.r r4
L2_console:
	ldw	r4,-2(bp)
	ldw	r3,4(bp)
	add	r4,r4,r3
	ldb	r4,r0(r4)
	push	r4
	la16	r2,_putc ; jaddr
	addi	r1,pc,2
	br.r	r2
	ldw	r4,-2(bp)
	addi	r4,r4,1
	stw	-2(bp),r4
L3_console:
	ldw	r4,-2(bp)
	ldw	r3,4(bp)
	add	r4,r4,r3
	ldb	r4,r0(r4)
	skip.eq r4,r0
	br L2_console
L1_console:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _putc
;	.end
_putc:
	; satisfy calling convention
	; we are not using stack so we can ommit some
	push r1
	push bp
	mov bp, sp
	; setup a pointer to uart reg at 0xff90
	la16 r4, 0xff90

	; wait until tx is free
check_tx_free_uart:
	ldi r1, 5
	add r1, r1, r4
	ldw r1, r0(r1)
	ldi r2, 0x60
	and r1, r1, r2
	skip.eq r2, r1
	br check_tx_free_uart
	; tx is free, load char (SP+2) and write to UART
	addi r1, bp, 4
	ldw r3, r0(r1)
	stb r0(r4), r3
	pop	bp
	pop	pc


_inituart:
	push r1
	push bp
	la16 r1, 0xff90
	mov r5, r1
	mov r1, r0
	stw 1(bp), r1   ; port + 1 0x00 - disable all interrupts
	ldi r1, 0x80
	stw 3(bp), r1   ; port + 3 0x80 enable dlab
	ldi r1, 32
	stw 0(bp), r1		; port + 0 set divisor to 1 LSB
	ldi r1, 0
	stw 1(bp), r1		; port + 1 set divisor to 1 MSB
	ldi r1, 3
	stw 3(bp), r1		; port + 3 set LCR - validate
	pop	bp
	pop	pc; MEMSET (char *dst, int c, uint n)
; bp + 8 has n
; bp + 6 has c
; bp + 4 has dst

_memset:
	push	r1
	push	bp
	mov	bp, sp
	ldw	r1,4(bp) ; load dst
	ldw	r2,6(bp) ; load c
	ldw	r3,8(bp) ; load n
	; skip if n = aligned
	andi r4,r3,1
	skip.eq r4, r0
	br _stosb
	; skip if dst = aligned
	andi r4, r1, 1
	skip.eq r4, r0
	br _stosb
	; both n and dst are 2 byte aligned
	shl r4, r2, 8
	or r2, r2, r4
	subi r3, r3, 2
_stoswL1:
	add	r4,r1,r3
	stw	r0(r4),r2
	addskpi.z r3, r3, -2
	br _stoswL1
	stw r0(r1), r2
	br _memsetend
_stosb:
	subi r3, r3, 1
_stosbL1:
	add	r4,r1,r3
	stb	r0(r4),r2
	addskpi.z r3, r3, -1
	br _stosbL1
	stb r0(r1), r2
_memsetend:
	pop	bp
	pop	pc;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff;	.global _kfree
;	.code
_kfree:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 4
	sub	sp, sp, r4
	ld16	r4, 2048
	push	r4
	ld16	r4, 1
	push	r4
	ldw	r4,4(bp)
	push	r4
	la16	r2,_memset ; jaddr
	addi	r1,pc,2
	br.r	r2
	ldw	r4,4(bp)
	shr	r3, r4, 4
	stw	-2(bp),r3
	ld16	r3, 15
	and	r4,r4,r3
	stw	-4(bp),r4
	ld16	r4, 1
	ldw	r3,-2(bp)
	shl	r3, r3, 1
	la16	r2,_kmem
	add	r3,r3,r2
	ldw	r2,r0(r3)
	ldw	r1,-4(bp)
	shl.r	r4, r4, r1
	or	r4,r2,r4
	stw	r0(r3),r4
L2_kalloc:
	mov	sp, bp
	pop	bp
	pop	pc

;	.global _initkmem
_initkmem:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 2
	sub	sp, sp, r4
	stw	-2(bp),r0
L4_kalloc:
	ldw	r4,-2(bp)
	shl	r4, r4, 1 ; [via index]
	la16	r3,_kmem
	ld16	r2, 0xffff
	stw	r4(r3),r2
L5_kalloc:
	ldw	r4,-2(bp)
	addi	r4,r4,1
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	ld16	r3, 16
	skip.gt	r4,r3
	br	L4_kalloc
	la16	r4,_kmem+32
	stw	r0(r4),r0
L3_kalloc:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _memset
	.bss
;	.global _kmem
_kmem:
	defs 34
;	.end
;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff;	.global _kmain
;	.code
_kmain:
	push	r1
	push	bp
	mov	bp, sp
	la16	r2,_inituart ; jaddr
	addi	r1,pc,2
	br.r	r2
	la16	r4,L2_kmain
	push	r4
	la16	r2,_kprintfold ; jaddr
	addi	r1,pc,2
	br.r	r2
	la16	r2,_initkmem ; jaddr
	addi	r1,pc,2
	br.r	r2
	mov	r1,r0
L1_kmain:
	pop	bp
	pop	pc

;	.extern _initkmem
;	.extern _kprintfold
;	.extern _inituart
	.data
L2_kmain:
	defstr "DME OS.."
;	.end
; http://www.tofla.iconbar.com/tofla/arm/arm02/index.htm
; !! need to add skipi instruction to make usable (uses too many regs atm)

; DIVIDE -------------------------
;
_div:
	pop r3 ; op1
	pop r2 ; op2
	mov r1, r0
	ldi r4, 1
divL1_pseudo_ops:
	skip.gt r2, r3
	br divL2_pseudo_ops
	shl r3, r3, 1
	shl r4, r4, 1
	br divL1_pseudo_ops

divL2_pseudo_ops:
	addskpi.nz r0, r4, -1
	br divL3_pseudo_ops
	shr r3, r3, 1
	shr r4, r4, 1

	skip.gte r2, r3
	br divL2_pseudo_ops
	sub r2, r2, r3
	or	r1, r1, r4
	br divL2_pseudo_ops

divL3_pseudo_ops:
	br.r bp ; return

; MODULO -------------------------
;
; (same algo as div, just returning remainer)
_mod:
	pop r3 ; op1
	pop r2 ; op2
	ldi r4, 1
modL1_pseudo_ops:
	skip.gt r2, r3
	br modL2_pseudo_ops
	shl r3, r3, 1
	shl r4, r4, 1
	br modL1_pseudo_ops

modL2_pseudo_ops:
	addskpi.nz r0, r4, -1
	br modL3_pseudo_ops
	shr r3, r3, 1
	shr r4, r4, 1

	skip.gte r2, r3
	br divL2_pseudo_ops
	sub r2, r2, r3
	br modL2_pseudo_ops

modL3_pseudo_ops:
	mov r1, r2
	br.r bp ; return

; MULTIPLY  -------------------------
;
; (unsigned)
_mult:
	pop r2 ; op1
	pop r3 ; op2
	mov r1, r0 ; result reg
; if a > b
	skip.gt r2, r3
	br multL2_pseudo_ops
; switch them
	mov r4, r2
	mov r2, r3
	mov r3, r4

multL2_pseudo_ops:
; while r1 > 1 loop
	ldi r4, 1
	skip.gt r2, r4
	br multL3_pseudo_ops
; check if r1 is even/odd
	andi r4, r2, 1
	addskpi.nz r4, r4, -1
	add r1, r1, r3
	shr r2, r2, 1
	shl r3, r3, 1
	br multL2_pseudo_ops
multL3_pseudo_ops:
	andi r4, r1, 1
	addskpi.nz r4, r4, -1
	add r1, r1, r3
	br.r bp