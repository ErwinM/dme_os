; boot.s
; there is no need to load the kernel high at boot
; dme has no awkward io mappings in low memory
; so:
; - we will load it at 0x0 at map it high
; - then jump into the high mapping

; lets assume (oh o) for now that the entire kernel is 2 pages
; and that dme will come up in system mode..

; setup mapping of kernel to 0x1000
; page 2 -> 0
; page 3 -> 1
; page 6 -> 6

; this code is linked at 0x1000 so it works when paging is on
.code 0x1000

ldi r1, 0x3
ldi r2, 0x2
wpte r2, r1

ldi r2, 0x103
ldi r3, 3
wpte r3, r2

; identity map the first 2 pages or execution would stop
wpte r0, r1
ldi r1, 1
wpte r1, r2

;identity map the 7th page for a stack (FIXME: ON CHIP MEM)
ldi r1, 7
la16 r2, 0x703
wpte r1, r2

; and the i/o memory mapped page
ld16 r2, 0x1f03
ldi r1, 31
wpte r1, r2
; turn on paging (not yet)
lcr r1
ori r1, r1, 4
scr r1

; setup IVEC
la16 r1, _trap
wivec r1

; setup SP
la16 r1, 0x4000
mov sp, r1



; jump into c
la16 r2, _kmain
; setup return address in case kmain returns (it shouldn't)
addi r1, pc, 2
br.r r2
hlt

_trap:
	defw 0xbabe











;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff;	.global _kprintf
;	.code
_kprintf:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 2
	sub	sp, sp, r4
	stw	-2(bp),r0
	la16	r4,L3_console
	br.r r4
L2_console:
	ldw	r4,-2(bp)
	ldw	r3,4(bp)
	add	r4,r4,r3
	ldb	r4,r0(r4)
	push	r4
	la16	r2,_putc ; jaddr
	addi	r1,pc,2
	br.r	r2
	ldw	r4,-2(bp)
	addi	r4,r4,1
	stw	-2(bp),r4
L3_console:
	ldw	r4,-2(bp)
	ldw	r3,4(bp)
	add	r4,r4,r3
	ldb	r4,r0(r4)
	skip.eq r4,r0
	br L2_console
L1_console:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _putc
;	.end
;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff;	.global _kmain
;	.code
_kmain:
	push	r1
	push	bp
	mov	bp, sp
	la16	r4,L2_kmain
	push	r4
	la16	r2,_kprintf ; jaddr
	addi	r1,pc,2
	br.r	r2
	la16	r2,_kinit1 ; jaddr
	addi	r1,pc,2
	br.r	r2
	ld16	r4, 2048
	push	r4
	la16	r2,_kfree ; jaddr
	addi	r1,pc,2
	br.r	r2
	mov	r1,r0
L1_kmain:
	pop	bp
	pop	pc

;	.extern _kfree
;	.extern _kinit1
;	.extern _kprintf
	.data
L2_kmain:
	defstr "DME OS.."
;	.end
_putc:
	; satisfy calling convention
	; we are not using stack so we can ommit some
	push r1
	push bp
	mov bp, sp
	; setup a pointer to uart reg at 0xff90
	la16 r4, 0xff90

	; wait until tx is free
check_tx_free_uart:
	ldi r1, 5
	add r1, r1, r4
	ldw r1, r0(r1)
	ldi r2, 0x60
	and r1, r1, r2
	addskp.z r2, r2, r1
	br check_tx_free_uart
	; tx is free, load char (SP+2) and write to UART
	addi r1, bp, 4
	ldw r3, r0(r1)
	stb r0(r4), r3
	pop	bp
	pop	pc; bp + 8 has n
; bp + 6 has c (already a word)
; bp + 4 has dst
_stosw:
	push	r1
	push	bp
	mov	bp, sp
	ldw	r1,4(bp) ; load dst
	ldw	r2,6(bp) ; load c
	ldw	r3,8(bp) ; load n
	subi r3, r3, 2
_stoswL1:
	add	r4,r1,r3
	stw	r0(r4),r2
	addskpi.z r3, r3, -2
	br _stoswL1
	stw r0(r1), r2
	pop	bp
	pop	pc

; bp + 8 has n
; bp + 6 has c
; bp + 4 has dst
_stosb:
	push	r1
	push	bp
	mov	bp, sp
	ldw	r1,4(bp) ; load dst
	ldw	r2,6(bp) ; load c
	ldw	r3,8(bp) ; load n
	subi r3, r3, 1
_stosbL1:
	add	r4,r1,r3
	stb	r0(r4),r2
	addskpi.z r3, r3, -1
	br _stosbL1
	stb r0(r1), r2
	pop	bp
	pop	pc;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff;	.global _memset
;	.code
_memset:
	push	r1
	push	bp
	mov	bp, sp
	ldw	r4,8(bp)
	andi	r4,r4,1
	skip.eq r4,r0
	br L2_string
	ldw	r4,4(bp)
	andi	r4,r4,1
	skip.eq r4,r0
	br L2_string
	ldw	r4,6(bp)
	shl	r3, r4, 8
	or	r4,r4,r3
	stw	6(bp),r4
	ldw	r4,8(bp)
	push	r4
	ldw	r4,6(bp)
	push	r4
	ldw	r4,4(bp)
	push	r4
	la16	r2,_stosw ; jaddr
	addi	r1,pc,2
	br.r	r2
	la16	r4,L3_string
	br.r r4
L2_string:
	ldw	r4,8(bp)
	push	r4
	ldw	r4,6(bp)
	push	r4
	ldw	r4,4(bp)
	push	r4
	la16	r2,_stosb ; jaddr
	addi	r1,pc,2
	br.r	r2
L3_string:
L1_string:
	pop	bp
	pop	pc

;	.extern _stosb
;	.extern _stosw
;	.end
;	DME assembly file, generated by lcc 4.2

 ; INT_MAX: ffffffff;	.global _kinit1
;	.code
_kinit1:
	push	r1
	push	bp
	mov	bp, sp
	la16	r4,_kmem
	stw	r0(r4),r0
L2_kalloc:
	pop	bp
	pop	pc

;	.global _kfree
_kfree:
	push	r1
	push	bp
	mov	bp, sp
	ldi	r4, 2
	sub	sp, sp, r4
	ld16	r4, 2048
	push	r4
	ld16	r4, 1
	push	r4
	ldw	r4,4(bp)
	push	r4
	la16	r2,_memset ; jaddr
	addi	r1,pc,2
	br.r	r2
	ldw	r4,4(bp)
	stw	-2(bp),r4
	ldw	r4,-2(bp)
	la16	r3,_kmem
	ldw	r3,r0(r3)
	stw	r0(r4),r3
	la16	r4,_kmem
	ldw	r3,-2(bp)
	stw	r0(r4),r3
L3_kalloc:
	mov	sp, bp
	pop	bp
	pop	pc

;	.extern _memset
	.bss
;	.global _kmem
_kmem:
	defs 2
;	.end
